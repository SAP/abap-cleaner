package com.sap.adt.abapcleaner.rules.syntax;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import com.sap.adt.abapcleaner.rulebase.RuleID;
import com.sap.adt.abapcleaner.rulebase.RuleTestBase;

class CommentTypeTest extends RuleTestBase {
	private CommentTypeRule rule;
	
	CommentTypeTest() {
		super(RuleID.COMMENT_TYPE);
		rule = (CommentTypeRule)getRule();
	}
	
	@BeforeEach
	void setUp() {
		// setup default test configuration (may be modified in the individual test methods)
	   rule.configActionForLeadingAsterisks.setEnumValue(CommentSeparatorAction.DELETE);
	   rule.configActionForTrailingAsterisks.setEnumValue(CommentSeparatorAction.CONVERT_TO_HYPHEN);
	}
	
	@Test
	void testMethodDescription() {
		buildSrc("*****************************************************************");
		buildSrc("* this check automatically distinguishes between");
		buildSrc("*   a) text comments, which will be transformed into \" comments");
		buildSrc("*   b) commented-out code lines, which will be kept as * comments");
		buildSrc("*****************************************************************");

		buildExp("    \" ----------------------------------------------------------------");
		buildExp("    \" this check automatically distinguishes between");
		buildExp("    \"   a) text comments, which will be transformed into \" comments");
		buildExp("    \"   b) commented-out code lines, which will be kept as * comments");
		buildExp("    \" ----------------------------------------------------------------");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testMixedTextAndCodeComments() {
		buildSrc("  METHOD comment_type_for_text.");
		buildSrc("* ------ 'given' ----------------");
		buildSrc("* create a contract with two fulfillments");
		buildSrc("    lo_contract_crt = create_contract( ).");
		buildSrc("");
		buildSrc("*    \" fulfill");
		buildSrc("*    lo_contract_ff1 = fulfill( io_contract           = lo_contract_crt");
		buildSrc("*                               iv_fulfillment_number = lc_fulfill_num_1 ).");
		buildSrc("*    lo_contract_ff2 = fulfill( io_contract           = lo_contract_ff1");
		buildSrc("*                               iv_fulfillment_number = lc_fulfill_num_2 ).");
		buildSrc("");
		buildSrc("* ------ 'when' ----------------");
		buildSrc("* perform contract change");
		buildSrc("    lo_contract_chg = change_contract( io_contract               = lo_contract_ff2");
		buildSrc("                                       iv_contract_change_number = lc_num_full_retro_chg ).");
		buildSrc("");
		buildSrc("* ------ 'then' ----------------");
		buildSrc("* set expected values");
		buildSrc("    lo_contract_exp = lo_contract_ff2.");
		buildSrc("    lo_contract_act = lo_contract_chg.");
		buildSrc("");
		buildSrc("*    lo_contract_exp->assert_equals_fully( io_act_contract = lo_contract_act ).");
		buildSrc("  ENDMETHOD.");

		buildExp("  METHOD comment_type_for_text.");
		buildExp("    \" ------ 'given' ----------------");
		buildExp("    \" create a contract with two fulfillments");
		buildExp("    lo_contract_crt = create_contract( ).");
		buildExp("");
		buildExp("*    \" fulfill");
		buildExp("*    lo_contract_ff1 = fulfill( io_contract           = lo_contract_crt");
		buildExp("*                               iv_fulfillment_number = lc_fulfill_num_1 ).");
		buildExp("*    lo_contract_ff2 = fulfill( io_contract           = lo_contract_ff1");
		buildExp("*                               iv_fulfillment_number = lc_fulfill_num_2 ).");
		buildExp("");
		buildExp("    \" ------ 'when' ----------------");
		buildExp("    \" perform contract change");
		buildExp("    lo_contract_chg = change_contract( io_contract               = lo_contract_ff2");
		buildExp("                                       iv_contract_change_number = lc_num_full_retro_chg ).");
		buildExp("");
		buildExp("    \" ------ 'then' ----------------");
		buildExp("    \" set expected values");
		buildExp("    lo_contract_exp = lo_contract_ff2.");
		buildExp("    lo_contract_act = lo_contract_chg.");
		buildExp("");
		buildExp("*    lo_contract_exp->assert_equals_fully( io_act_contract = lo_contract_act ).");
		buildExp("  ENDMETHOD.");

		testRule();
	}

	@Test
	void testAutoGeneratedCommentUnchanged() {
		buildSrc("* <SIGNATURE>---------------------------------------------------------------------------------------+");
		buildSrc("* | such an automatically generated signature must, of course, remain unchanged");
		buildSrc("* +-------------------------------------------------------------------------------------------------+");
		buildSrc("* | [<---] ET_TABLE        TYPE        TY_TT_TABLE_TYPE");
		buildSrc("* +--------------------------------------------------------------------------------------</SIGNATURE>");
		buildSrc("  METHOD comment_type_for_text.");
		buildSrc("  ENDMETHOD.");

		copyExpFromSrc();
		
		testRule();
	}

	@Test
	void testAsteriskSeparators() {
		buildSrc("*    \" sometimes, the asterisk is also used to separate code sections");
		buildSrc("***  leading asterisks");
		buildSrc("*    trailing asterisks ******************************");
		buildSrc("**** leading and trailing asterisks ******************");
		buildSrc("******************************************************");

		buildExp("    \" sometimes, the asterisk is also used to separate code sections");
		buildExp("    \" leading asterisks");
		buildExp("    \" trailing asterisks ------------------------------");
		buildExp("    \" leading and trailing asterisks ------------------");
		buildExp("    \" -----------------------------------------------------");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	// -------------------------------------------------------------------------
	// test configuration settings for leading asterisks 
	
	@Test
	void testKeepLeadingAsterisks() {
	   rule.configActionForLeadingAsterisks.setEnumValue(CommentSeparatorAction.KEEP);

	   buildSrc("*     \" sometimes, the asterisk is also used to separate code sections");
		buildSrc("***   leading asterisks");
		buildSrc("***** more leading asterisks");

	   buildExp("    \" sometimes, the asterisk is also used to separate code sections");
		buildExp("    \" ** leading asterisks");
		buildExp("    \" **** more leading asterisks");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testConvertLeadingAsterisksToHyphen() {
	   rule.configActionForLeadingAsterisks.setEnumValue(CommentSeparatorAction.CONVERT_TO_HYPHEN);

	   buildSrc("*     \" sometimes, the asterisk is also used to separate code sections");
		buildSrc("***   leading asterisks");
		buildSrc("***** more leading asterisks");

	   buildExp("    \" sometimes, the asterisk is also used to separate code sections");
		buildExp("    \" -- leading asterisks");
		buildExp("    \" ---- more leading asterisks");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testConvertLeadingAsterisksToEquals() {
	   rule.configActionForLeadingAsterisks.setEnumValue(CommentSeparatorAction.CONVERT_TO_EQUALS);

	   buildSrc("*     \" sometimes, the asterisk is also used to separate code sections");
		buildSrc("***   leading asterisks");
		buildSrc("***** more leading asterisks");

	   buildExp("    \" sometimes, the asterisk is also used to separate code sections");
		buildExp("    \" == leading asterisks");
		buildExp("    \" ==== more leading asterisks");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testDeleteLeadingAsterisks() {
	   rule.configActionForLeadingAsterisks.setEnumValue(CommentSeparatorAction.DELETE);

	   buildSrc("*     \" sometimes, the asterisk is also used to separate code sections");
		buildSrc("***   leading asterisks");
		buildSrc("***** more leading asterisks");

	   buildExp("    \" sometimes, the asterisk is also used to separate code sections");
		buildExp("    \" leading asterisks");
		buildExp("    \" more leading asterisks");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	// -------------------------------------------------------------------------
	// test configuration settings for trailing asterisks 
	
	@Test
	void testKeepTrailingAsterisks() {
	   rule.configActionForTrailingAsterisks.setEnumValue(CommentSeparatorAction.KEEP);

		buildSrc("*    trailing asterisks ******************************");
		buildSrc("**** leading and trailing asterisks ******************");

		buildExp("    \" trailing asterisks ******************************");
		buildExp("    \" leading and trailing asterisks ******************");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testConvertTrailingAsterisksToHyphen() {
	   rule.configActionForTrailingAsterisks.setEnumValue(CommentSeparatorAction.CONVERT_TO_HYPHEN);

		buildSrc("*    trailing asterisks ******************************");
		buildSrc("**** leading and trailing asterisks ******************");

		buildExp("    \" trailing asterisks ------------------------------");
		buildExp("    \" leading and trailing asterisks ------------------");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testConvertTrailingAsterisksToEquals() {
	   rule.configActionForTrailingAsterisks.setEnumValue(CommentSeparatorAction.CONVERT_TO_EQUALS);

		buildSrc("*    trailing asterisks ******************************");
		buildSrc("**** leading and trailing asterisks ******************");

		buildExp("    \" trailing asterisks ==============================");
		buildExp("    \" leading and trailing asterisks ==================");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testDeleteTrailingsterisks() {
	   rule.configActionForTrailingAsterisks.setEnumValue(CommentSeparatorAction.DELETE);

		buildSrc("*    trailing asterisks ******************************");
		buildSrc("**** leading and trailing asterisks ******************");

		buildExp("    \" trailing asterisks");
		buildExp("    \" leading and trailing asterisks");

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}

	@Test
	void testAutoGeneratedFormHeader() {
		// ensure that the following auto-generated header is NOT changed
		// although the majority of lines does NOT start with *&

		buildSrc("*&---------------------------------------------------------------------*");
		buildSrc("*&      Form  ANY_FORM");
		buildSrc("*&---------------------------------------------------------------------*");
		buildSrc("*       form description");
		buildSrc("*----------------------------------------------------------------------*");
		buildSrc("*  -->  p1        parameter description");
		buildSrc("*  <--  p2        parameter description");
		buildSrc("*----------------------------------------------------------------------*");

		copyExpFromSrc();

		putAnyMethodAroundSrcAndExp();
		
		testRule();
	}
}
