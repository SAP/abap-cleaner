package com.sap.adt.abapcleaner.rulehelpers;

import static org.junit.jupiter.api.Assertions.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import com.sap.adt.abapcleaner.base.ABAP;
import com.sap.adt.abapcleaner.base.Language;
import com.sap.adt.abapcleaner.base.StringUtil;

class CommentIdentifierTest {
	private static CommentIdentifier commentIdentifier;
	
	private ArrayList<String> lines = new ArrayList<String>();
	private HashMap<String, WordFrequency> freqOfWords = new HashMap<>();
	private String freqTable;
	
	@BeforeAll
	static void setUpBeforeClass() throws Exception {
		commentIdentifier = new CommentIdentifier(); 
	}

	@AfterAll
	static void tearDownAfterClass() throws Exception {
	}

	void buildSrc(String line) {
		lines.add(line);
	}
	
	void testSrcIsAbap() {
		testSrc(true, false, Language.ABAP);
	}
	
	void testSrcIsText() {
		testSrc(false, false, Language.ABAP);
	}
	
	void testSrcContextIsAbap() {
		testSrc(true, true, Language.ABAP);
	}
	
	void testSrcContextIsText() {
		testSrc(false, true, Language.ABAP);
	}
	
	private void testSrc(boolean expAbapCode, boolean testWithContextOnly, Language codeLanguage) {
		for (int line = 0; line < lines.size(); ++line) {
			if (!testWithContextOnly) {
				// test without the context of the previous and next line
				test(lines.get(line), null, null, expAbapCode, codeLanguage);
			}

			// test with the context of the previous and next line
			String prevLine = (line == 0) ? null : lines.get(line - 1);
			String nextLine = (line + 1 == lines.size()) ? null : lines.get(line + 1);
			if (prevLine != null || nextLine != null) {
				test(lines.get(line), prevLine, nextLine, expAbapCode, codeLanguage);
			}
		}
	}
	
	void testLineIsAbap(String lineText) {
		test(lineText, null, null, true, Language.ABAP);
	}

	void testLineIsText(String lineText) {
		test(lineText, null, null, false, Language.ABAP);
	}

	private void test(String lineText, String prevLine, String nextLine, boolean expCode, Language codeLanguage) {
		CommentIdentification result = commentIdentifier.identifyComment(lineText, false, prevLine, nextLine, false, codeLanguage);
		
		assertTrue(result.canDecide());
		int codeProbability = result.getCodeProbabilityPercent();
		assertTrue(0 <= codeProbability && codeProbability <= 100);
		assertEquals(result.isCode(), expCode);
		assertEquals(result.isTextual(), !expCode);
		
		result = commentIdentifier.identifyComment(lineText, false, prevLine, nextLine, true, codeLanguage);
		String reasons = result.getReasonsWithSep(System.lineSeparator());
		assertTrue(reasons.length() > 0);
	}
	
	@Test
	void testAutoGeneratedSignature() {
		buildSrc("* <SIGNATURE>---------------------------------------------------------------------------------------+");
		buildSrc("* | such an automatically generated signature must, of course, remain unchanged");
		buildSrc("* +-------------------------------------------------------------------------------------------------+");
		buildSrc("* | [<---] ET_ANY_PARAM        TYPE        ANY_TYPE");
		buildSrc("* +--------------------------------------------------------------------------------------</SIGNATURE>");
		
		testSrcIsAbap();
	}
	
	@Test
	void testAutoGeneratedIncludeHeader() {
		buildSrc("*&---------------------------------------------------------------------*");
		buildSrc("*& Include any_include");
		buildSrc("*&---------------------------------------------------------------------*");

		testSrcIsAbap();
	}
	
	@Test
	void testMultipleAsterisks() {
		buildSrc("********************************");
		buildSrc("*****  method description  *****");
		buildSrc("********************************");
		
		testSrcIsText();
	}
	
	@Test
	void testQuotMarkLineComment() {
		// " comments are regarded as a normal part of the ABAP code: 
		// only * comments are differentiated into commented-out ABAP code and English text 
		testLineIsAbap("  \" comment");
		testLineIsAbap("    \" another comment");
		testLineIsAbap("      \" yet another comment");
	}

	@Test
	void testQuotMarkTextQuote() {
		testLineIsText("*  \"This is a quote, not an ABAP Comment!\"");
		testLineIsText("*  \"veni, vidi, vici\"");
	}

	@Test
	void testLinesWithStrings() {
		testLineIsAbap("*   lv_text = 'text'.");
		testLineIsAbap("*   lv_text = `text`.");
		testLineIsAbap("*   lv_text = |Count: { lv_count }|.");
	}

	@Test
	void testMultipleHyphens() {
		testLineIsText("* ----- 'given' ----------------");
		testLineIsText("* ----- 'when'");
		testLineIsText("* ----- any other comment");
		testLineIsText("*      ----- comment with indent");
	}

	@Test
	void testMultipleEqualsSigns() {
		testLineIsText("* ===== next important section");
		testLineIsText("* =============================");
		testLineIsText("* ===== any other comment");
		testLineIsText("*      ===== comment with indent");
	}
	
	@Test
	void testExpectedIndent() {
		buildSrc("*    TRY.");
		buildSrc("*        lo_instance->any_method( <ls_data>-field ).");
		buildSrc("*      CATCH cx_message.");
		buildSrc("*        \" handler");
		buildSrc("*    ENDTRY.");
		
		testSrcIsAbap();
	}
	
	@Test
	void testUnexpectedIndent() {
		buildSrc("*    try an operation.");
		buildSrc("*    call a method.");
		buildSrc("*    catch a message.");
		buildSrc("*    implement an error handler.");
		buildSrc("*    endtry.");
		
		testSrcIsText();
	}

	@Test
	void testGermanText() {
		testLineIsText("*  Auch Texte in deutscher Sprache -");
		testLineIsText("*  wie sie zuweilen in klassischem Code noch zu finden sind -");
		testLineIsText("*  sollten als Text erkannt werden.");
	}

	@Test
	void testLowerCaseKeywords() {
		testLineIsAbap("*  DATA tstp TYPE timestamp.");
		testLineIsAbap("*  DATA i TYPE int8.");

		testLineIsText("*  TIMESTAMP or TIMESTAMPL.");
		testLineIsText("*  INT4 or INT8.");
	}

	@Test
	void testUpperCaseNonKeyword() {
		// words that are in upper case, but no ABAP keywords
		testLineIsText("*  ABC or DEF or GHI");
		testLineIsText("*  ABCDEFGHIJ");
	}

	@Test
	void testApostropheInside() {
		// words that are neither in the list of frequent English words nor ABAP keywords 
		testLineIsText("*  abc's or def's");
		testLineIsText("*  abcdefg'hij");
	}

	@Test
	void testPeriodAndColonInsideLine() {
		testLineIsText("*  first sentence. second sentence.");
		testLineIsText("*  this is a textual comment: the colon is at a late position in the line");
	}
	
	@Test
	void testDoubleAsteriskOnly() {
		testLineIsText("**");
	}
	
	@Test
	void testDecisionBasedOnPrevOrNextLine() {
		buildSrc("*  This is text.");
		buildSrc("*");
		buildSrc("*");
		buildSrc("*  This is text, too");
		
		testSrcContextIsText();
	}

	private void testIdentifyWithOutput(String codeText, CommentIdentifierMode mode, int expLineCount) {
		final int headerLineCount = 1;

		// ensure the method works without output and that separator frequencies are returned
		commentIdentifier.resetSeparatorFrequencies();
		commentIdentifier.identifyComments(codeText, null, mode);
		String sepFreq = commentIdentifier.getSeparatorFrequencies(); 
		assertTrue(StringUtil.split(sepFreq, '\n', true).length > 1);
		
		// ensure the output contains the expected number of lines (+ 1 header line) 
		StringBuilder output = new StringBuilder();
		commentIdentifier.identifyComments(codeText, output, mode);
		int actLineCount = StringUtil.instrCount(output.toString(), '\n');
		assertEquals(expLineCount, actLineCount - headerLineCount);
		
		// ensure that a scope description is available
		assertTrue(CommentIdentifier.getScopeDescription(mode).length() > 0);
	}

	@Test
	void testIdentifyWithOutput() {
		String LINE_SEP = ABAP.LINE_SEPARATOR;
		String code = "  \" quotation mark comment"
			+ LINE_SEP + "  \""
			+ LINE_SEP + "  IF a = 1."
			+ LINE_SEP + "    RETURN."
			+ LINE_SEP + "  ENDIF."
			+ LINE_SEP
			+ LINE_SEP + "* first asterisk comment"
			+ LINE_SEP + "* second asterisk comment";

		// the second line which just consist of the comment sign " is skipped, therefore expect just 1 quotation mark comment
		testIdentifyWithOutput(code, CommentIdentifierMode.NON_LINE_START_COMMENTS, 1);
		testIdentifyWithOutput(code, CommentIdentifierMode.CODE_ONLY, 3);
		testIdentifyWithOutput(code, CommentIdentifierMode.LINE_START_COMMENTS, 2);
		testIdentifyWithOutput(code, CommentIdentifierMode.ALL_COMMENT_LINES, 3);
	}
	
	@Test
	void testWordFrequenciesFromCommentSamples() {
		// create an array of sample comment lines for which word frequency statistics will be created
		String[] lines = new String[] {
			// the following lines should be skipped:",
			"* asterisk comment lines should be skipped",
			"",
			"  \" CALL METHOD any_method EXPORTING a = 1.",

			// the following lines must be skipped:",
	      " \" TODO: variable is assigned but never used (ABAP cleaner)",
	      "* do not include other source files here!!!",
	      "* public components of class ",
	      "* protected components of class ",
	      "* private components of class ",
	      "\" Call the entity set generated method",
	      "  \" Send specific entity data to the caller interfaces",
	      "    \" In case of initial values - unbind the entity reference",	
	      
			// the following lines should be considered:",
			"  \" this line should be considered",
			"  \" this line, too",
			"  \" und auch diese Zeile (in Deutsch)",

			// duplicate lines should NOT be considered multiple times
			"  \" this line should be considered",
			"  \" this line should be considered",

			// typical ABAP Doc tags and parameter names should be removed, but the text considered:
	      " \" <p class=\"shorttext synchronized\" lang=\"en\">Method description</p>",
	      " \" <p class=\"shorttext synchronized\" lang=\"de\">Another method description</p>",
	      " \" @parameter iv_any_parameter | parameter description",
	      " \" @parameter iv_other_parameter | another parameter description",
	      " \" @raising cx_any_exception",
	      " \" text with tags <br/> and <br />",
		
			// non-textual words should be skipped, but the rest be considered:
	      " \" consider text, but not identifiers such as iv_text, camelCase, c5, <ls_data>, VALUE #( ), sy-subrc",
	      " \" Also, don't consider any- and -other and remove 'quotation marks'."
		};

		String oldTable = "";
		String context = null;
		
		for (int pass = 0; pass < 2; ++pass) {
			// add the samples to the comment identifier and get word frequencies
			commentIdentifier = new CommentIdentifier();
			commentIdentifier.addCommentSamples(lines, CommentIdentifierMode.NON_LINE_START_COMMENTS, Language.ABAP);

			freqOfWords = new HashMap<>();
			freqTable = commentIdentifier.getWordFrequencies(oldTable, freqOfWords);

			// to build the following assertFreq(...) calls, the following helper method may be used:
			// String assertCode = buildAssertCode();
			
			// check expected statistics; since the comment lines are added to a HashSet, the 'first context'
			// is random; the assertFreq() method only checks the context for unambiguous cases (expCount == 1)
			
			// words from English comment 'this line should be considered'
			context = "E this line should be considered";
			assertFreq("this", 2, 2, false, context);
			assertFreq("line", 2, 2, false, context);
			assertFreq("should", 1, 1, false, context);
			assertFreq("be", 1, 1, false, context);
			assertFreq("considered", 1, 1, false, context);
	
			// words from English comment 'this line, too'
			context = "E this line too";
			assertFreq("this", 2, 2, false, context);
			assertFreq("too", 1, 1, false, context);
	
			// words from German comment 'und auch diese Zeile (in Deutsch)'
			context = "D und auch diese Zeile in Deutsch";
			assertFreq("und", 1, 1, true, context);
			assertFreq("auch", 1, 1, true, context);
			assertFreq("diese", 1, 1, true, context);
			assertFreq("Zeile", 1, 1, true, context);
			assertFreq("in", 1, 1, true, context);
			assertFreq("Deutsch", 1, 1, true, context);
			
			// words from English line '<p class=\"shorttext synchronized\" lang=\"en\">Method description</p>'
			context = "E Method description";
			assertFreq("Method", 1, 2, false, context);
			assertFreq("description", 4, 4, false, context);
	
			// words from English line '<p class=\"shorttext synchronized\" lang=\"de\">Another method description</p>'
			context = "E Another method description";
			assertFreq("Another", 1, 2, false, context);
			assertFreq("method", 1, 2, false, context);
			assertFreq("description", 4, 4, false, context);
	
			// words from English line '@parameter iv_any_parameter | parameter description'
			context = "E parameter description";
			assertFreq("parameter", 2, 2, false, context);
			assertFreq("description", 4, 4, false, context);
	
			// words from English line '@parameter iv_other_parameter | another parameter description'
			context = "E another parameter description";
			assertFreq("another", 1, 2, false, context);
			assertFreq("parameter", 2, 2, false, context);
			assertFreq("description", 4, 4, false, context);
			
			// words from English line 'text with tags <br/> and <br />'
			context = "E text with tags and";
			assertFreq("text", 2, 2, false, context);
			assertFreq("with", 1, 1, false, context);
			assertFreq("tags", 1, 1, false, context);
			assertFreq("and", 3, 3, false, context);
			
			// words from English comment 'consider text, but not identifiers such as iv_text, camelCase, c5, <ls_data>, VALUE #( ), sy-subrc'
			context = "E consider text but not identifiers such as _ _ _ _ _ _";
			assertFreq("consider", 2, 2, false, context);
			assertFreq("but", 1, 1, false, context);
			assertFreq("not", 1, 1, false, context);
			assertFreq("identifiers", 1, 1, false, context);
			assertFreq("such", 1, 1, false, context);
			assertFreq("as", 1, 1, false, context);
	
			// words from English comment 'Also, don't consider any- and -other and remove 'quotation marks'.'
			context = "E Also don't consider _ and _ and remove quotation marks";
			assertFreq("Also", 1, 1, false, context);
			assertFreq("don't", 1, 1, false, context);
			assertFreq("consider", 2, 2, false, context);
			assertFreq("and", 3, 3, false, context);
			assertFreq("remove", 1, 1, false, context);
			assertFreq("quotation", 1, 1, false, context);
			assertFreq("marks", 1, 1, false, context);
	
			// check some words that must NOT be found in the statistics
			assertNoFreq("asterisk", "skipped");
			assertNoFreq("CALL", "any_method");
			assertNoFreq("AbapCleaner", "TODO", "Cleaner", "cleaner", "source", "public", "protected", "private", "entity", "specific", "initial");
			assertNoFreq("shorttext", "synchronized", "iv_any_parameter", "iv_other_parameter", "cx_any_exception", "<br/>");
			assertNoFreq("iv_text", "camelCase", "c5", "<ls_data>", "ls_data", "VALUE", "sy", "subrc", "sy-subrc");
			assertNoFreq("any-", "-other", "'quotation", "marks'");

			// test the call without the HashMap parameter 
			String freqTable2 = commentIdentifier.getWordFrequencies(oldTable);
			assertEquals(freqTable2, freqTable);

			if (pass == 0) {
				// expect the words 'additional' and 'comment' to be unknown as of now 
				assertNoFreq("additional", "comment");

				// for the second pass, provide the existing table and add an additional comment line
				oldTable = freqTable;
				lines = Arrays.copyOf(lines, lines.length + 1);
				lines[lines.length - 1] = " \" additional comment";

			} else {
				// expect two more words from the English comment 'additional comment' that was added in the second pass
				context = "E additional comment";
				assertFreq("additional", 1, 1, false, context);
				assertFreq("comment", 1, 1, false, context);
			}
		}
	}
	
	private void assertFreq(String expWord, int expCount, int expCountUpperAndLower, boolean expIsGerman, String expFirstContext) {
		// ensure that the word is found in the HashMap with the expected statistics
		WordFrequency freq = freqOfWords.get(expWord);
		assertNotNull(freq);
		assertEquals(freq.count, expCount);
		assertEquals(freq.countUpperAndLower, expCountUpperAndLower);
		assertEquals(freq.isGerman, expIsGerman);

		// since the comment lines are added to a HashSet, the 'first context' is random; therefore, only check 
		// unambiguous cases (expCount == 1) 
		if (expCount == 1)
			assertEquals(freq.firstContext, expFirstContext);
		
		// ensure that the word also appears as an entry in the frequency table
		assertTrue(freqTable.indexOf("\t" + expWord + "\t") > 0);
	}

	private void assertNoFreq(String... words) {
		for (String word : words) {
			assertNoFreq(word);
		}
	}

	private void assertNoFreq(String word) {
		// ensure that the word is NOT found in the HashMap
		assertNull(freqOfWords.get(word));
	
		// ensure that the word does NOT appear as an entry in the frequency table
		assertTrue(freqTable.indexOf("\t" + word + "\t") < 0);
	}
	
	@SuppressWarnings("unused")
	private String buildAssertCode() {
		// helper method to build the assertFreq calls for a concrete sample of comments; 
		// the result must be manually checked for correctness  
		HashSet<String> firstContexts = new HashSet<>();
		for (WordFrequency wordFreq : freqOfWords.values()) {
			firstContexts.add(wordFreq.firstContext);
		}
		StringBuilder asserts = new StringBuilder();
		for (String firstContext : firstContexts) {
			asserts.append("context = \"" + firstContext + "\";");
			asserts.append(System.lineSeparator());

			for (String word : freqOfWords.keySet()) {
				WordFrequency freqOfWord = freqOfWords.get(word);
				if (!freqOfWord.firstContext.equals(firstContext))
					continue;
				asserts.append("assertFreq(\"" + word + "\"");
				asserts.append(", " + String.valueOf(freqOfWord.count));
				asserts.append(", " + String.valueOf(freqOfWord.countUpperAndLower));
				asserts.append(", " + (freqOfWord.isGerman ? "true" : "false"));
				asserts.append(", context);");
				asserts.append(System.lineSeparator());
			}
			asserts.append(System.lineSeparator());
		}
		return asserts.toString();
	}
	
	@Test
	void testGetFrequentEnglishTypos() {
		HashMap<String, String> freqTypos = CommentIdentifier.getFrequentEnglishTypos();

		// the HashMap may contain multiple entries for upper and lower case, but at least the provided ...Count()
		assertTrue(freqTypos.size() >= CommentIdentifier.getFrequentEnglishTypoCount());

		// ensure that some of the most common typos and their corrections are found
		assertEquals("whether", freqTypos.get("wether"));
		assertEquals("occur", freqTypos.get("occurr"));
		assertEquals("successful", freqTypos.get("successfull"));
		assertEquals("necessary", freqTypos.get("neccessary"));
		assertEquals("existence", freqTypos.get("existance"));
		assertEquals("parameter", freqTypos.get("paramter"));
		assertEquals("transferred", freqTypos.get("transfered"));
		assertEquals("separate", freqTypos.get("seperate"));
		assertEquals("dependent", freqTypos.get("dependant"));
		assertEquals("structure", freqTypos.get("strucutre"));
		assertEquals("chosen", freqTypos.get("choosen"));
		assertEquals("already", freqTypos.get("allready"));
	}
	
	@Test
	void testGetFrequentBritishEnglish() {
		HashMap<String, String> freqTypos = CommentIdentifier.getFrequentBritishEnglish();
		
		// the HashMap may contain multiple entries for upper and lower case, but at least the provided ...Count()
		assertTrue(freqTypos.size() >= CommentIdentifier.getFrequentBritishEnglishCount());

		// ensure that some of the most common British English words and their American English counterparts are found
		assertEquals("analyzed", freqTypos.get("analysed"));
		assertEquals("behavior", freqTypos.get("behaviour"));
		assertEquals("favorite", freqTypos.get("favourite"));
		assertEquals("initialization", freqTypos.get("initialisation"));
		assertEquals("neighbor", freqTypos.get("neighbour"));
		assertEquals("optimize", freqTypos.get("optimise"));
	}

	void testDdlLineIsDdl(String lineText) {
		test(lineText, null, null, true, Language.DDL);
	}

	void testDdlLineIsText(String lineText) {
		test(lineText, null, null, false, Language.DDL);
	}

	@Test
	void testDdlAnnotation() {
		testDdlLineIsDdl("@Annotation: 'value'");
		testDdlLineIsDdl("@Annotation.subAnno: 'value'");
		testDdlLineIsDdl("@Annotation: { subAnno: 'value', otherSubAnno: 'value' }");
		testDdlLineIsDdl("@Annotation.array: [ 'value', 'otherValue' }");
	}

	@Test
	void testDdlCode() {
		testDdlLineIsDdl("//define view entity I_Any");
		testDdlLineIsDdl("//  as select from any_table as Any");
		testDdlLineIsDdl("//    left outer to one join I_Other as Other");
		testDdlLineIsDdl("//      on $projection.KeyField = Other.KeyField");
		testDdlLineIsDdl("//  association [0..*] to I_Other as _Third");
		testDdlLineIsDdl("//    on $projection.KeyField = _Third.KeyField");
		testDdlLineIsDdl("//{");
		testDdlLineIsDdl("//  key Any.AnyField,");
		testDdlLineIsDdl("//      Any.OtherField,");
		testDdlLineIsDdl("//      Any.ThirdField as ThirdField,");
		testDdlLineIsDdl("//      Other.FourthField,");
		testDdlLineIsDdl("//      _Third.FifthField,");
		testDdlLineIsDdl("//      concat('a', 'b') as ConcatField,");
		testDdlLineIsDdl("//      _Third.SixthField as SixthField");
		testDdlLineIsDdl("//}");
	}

	@Test
	void testDdlText() {
		testDdlLineIsText("/*****/");
		testDdlLineIsText("/*******************************************/");
		// text with typos
		testDdlLineIsText("// to optimise perfomance, only expose small selction of");
		testDdlLineIsText("// fields neccessary for the applicaton; futher detials");
		testDdlLineIsText("//could be made avaialable separatly via extention");
		// German text
		testDdlLineIsText("// Umlaute äöüß können auch erkannt werden");
	}

	@Test
	void testIdentifyDdlWithOutput() {
		String LINE_SEP = System.lineSeparator();
		String code = "// line-start comment"
			+ LINE_SEP + "  //"
			+ LINE_SEP + "  // non-line-start comment A"
			+ LINE_SEP + "  /* non-line-start comment B */"
			+ LINE_SEP + "  @Annotation.subAnno: 'value'"
			+ LINE_SEP + "  define view entity I_Any as select from dtab {"
			+ LINE_SEP + "  key AnyField"
			+ LINE_SEP
			+ LINE_SEP + "-- non-line-start comment C" // only "//" at line-start counts, because this is how multi-line code is commented out
			+ LINE_SEP + "}";

		// the second line, which just consist of the comment sign //, is skipped
		testIdentifyWithOutput(code, CommentIdentifierMode.NON_LINE_START_COMMENTS, 3);
		testIdentifyWithOutput(code, CommentIdentifierMode.CODE_ONLY, 4);
		testIdentifyWithOutput(code, CommentIdentifierMode.LINE_START_COMMENTS, 1);
		testIdentifyWithOutput(code, CommentIdentifierMode.ALL_COMMENT_LINES, 4);
	}
	
}
