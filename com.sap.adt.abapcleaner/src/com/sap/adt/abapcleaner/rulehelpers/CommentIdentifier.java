package com.sap.adt.abapcleaner.rulehelpers;

import com.sap.adt.abapcleaner.base.*;
import com.sap.adt.abapcleaner.programbase.Program;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;

/** 
 Determines whether a line-start comment contains (English / German) text or ABAP code. 
 Provides a probability and a textual description of the reasons for the decision. 
*/
public class CommentIdentifier {
   private static final String SEP_AT_LINE_START_MARK = "B";
   private static final String SEP_AT_LINE_END_MARK = "E";

   private static final String ENGLISH_LINE_PREFIX = "E";
	private static final String GERMAN_LINE_PREFIX = "D";
	private static final String NON_TEXTUAL_WORD = "_";
	private static final char[] GERMAN_SPECIAL_CHARS = new char[] { '\u00e4', '\u00f6', '\u00fc', '\u00df', '\u00c4', '\u00d6', '\u00dc' }; // ae, oe, ue, ss, Ae, Oe, Ue
	
   private static char[] abapStringEndChars = new char[] {ABAP.QUOT_MARK};
   private static char abapStringEscapeChar = ABAP.QUOT_MARK;

   private static char[] abapStringEndChars2 = new char[] {ABAP.QUOT_MARK2};
   private static char abapString2EscapeChar = ABAP.QUOT_MARK2;
   
   private static char[] abapStringTemplateEndChars = new char[] {ABAP.BRACE_OPEN, ABAP.PIPE};
   private static char abapStringTemplateEscapeChar = ABAP.STRING_TEMPLATE_ESCAPE_CHAR;
   
   private static char[] ddlStringEndChars = new char[] {DDL.QUOT_MARK};
   private static char ddlStringEscapeChar = DDL.QUOT_ESCAPE_CHAR;

	private final static String[] wordFreqRemoveAbapTexts = new String[] { 	
			"<p class=\"shorttext synchronized\" lang=\"en\">", 
			"<p class=\"shorttext synchronized\" lang=\"de\">",
			"<p class=\"shorttext synchronized\">", 
			"</p>",
			"<br/>",
			"<br />" };
	
	private final static String[] wordFreqSkipAbapTexts = new String[] { 
	      "TODO: variable is assigned but never used ("+ Program.PRODUCT_NAME + ")",
	      "do not include other source files here!!!",
	      "public components of class ",
	      "protected components of class ",
	      "private components of class ",
	      "Call the entity set generated method",
	      "Send specific entity data to the caller interfaces",
	      "In case of initial values - unbind the entity reference" };

	private final static char[] wordFreqSkipChars = new char[] { '/', '<', '>', '_', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; 

   private static boolean isInitialized;
   
   // lists of English and German words frequently found in comments of ABAP code
   private static HashSet<String> frequentEnglishWords;
   private static HashSet<String> frequentGermanWords;
   private static HashMap<String, String> frequentEnglishTypos;
   private static HashMap<String, String> frequentBritishEnglish;
   private static int frequentEnglishTypoCount;
   private static int frequentBritishEnglishCount;

   private static HashSet<String> nonEnglishAbapUpperCaseKeywords;
   private static HashSet<String> nonEnglishAbapLowerCaseKeywords;
   private static HashSet<String> nonEnglishDdlLowerCaseKeywords; // includes both DDL and DCL keywords
   private static HashSet<String> abapSeparators;
   private static HashSet<String> ddlSeparators;
   private static HashSet<String> textInAbapSeparators; // separators of textual content in ABAP documents 
   private static HashSet<String> textInDdlSeparators;  // separators of textual content in DDL documents
   // private static HashSet<String> ambiguousSeparators;

   private static String[] autoGeneratedAbapPrefixes;

   private static HashSet<String> abapLevelOpeners;
   private static HashSet<String> abapLevelClosers;

   private HashMap<String, Integer> separatorFrequency = new HashMap<String, Integer>();

   private HashSet<String> lineSamples = new HashSet<>();

	private static class Line {
		int indent;
		// String text;
		String comment;
		String[] words;
		BitSet wordsMayBeKeywords;
		String[] separators;
		boolean isInnerCommentLine;

		final int getWordCount() { return (words == null) ? 0 : words.length; }

		final int getSeparatorCount() { return (separators == null) ? 0 : separators.length; }

		Line(int indent, String text, String comment, String[] words, BitSet wordsMayBeKeywords, String[] separators) {
			this(indent, text, comment, words, wordsMayBeKeywords, separators, false);
		}
		Line(int indent, String text, String comment, String[] words, BitSet wordsMayBeKeywords, String[] separators, boolean isInnerCommentLine) {
			this.indent = indent;
			// this.text = text;
			this.comment = comment;
			this.words = words;
			this.wordsMayBeKeywords = wordsMayBeKeywords;
			this.separators = separators;
			this.isInnerCommentLine = isInnerCommentLine;
		}

		final int expectedIndentChangeForNextAbapLine() {
			if (words == null || words.length == 0)
				return 0;

			if (abapLevelOpeners.contains(getHashSetKey(words[0]))) {
				return AbapCult.stringEquals(words[0], "TRY", true) ? 4 : 2;
			} else {
				return 0;
			}
		}

		final int expectedIndentChangeForThisAbapLine() {
			if (words == null || words.length == 0)
				return 0;
			if (abapLevelClosers.contains(getHashSetKey(words[0]))) {
				return AbapCult.stringEquals(words[0], "ENDTRY", true) || AbapCult.stringEquals(words[0], "ENDCASE", true) ? -4 : -2;
			} else {
				return 0;
			}
		}
		
		final String getSep(int index) {
			return (separators == null || index < 0 || index >= separators.length) ? null : separators[index];
		}
		
		final String getSepFromEnd(int indexFromEnd) {
			if (separators == null)
				return null;
			int index = separators.length - 1 - indexFromEnd;
			return (index < 0) ? null : separators[index];
		}
		
		final String getWordFromEnd(int indexFromEnd) {
			if (words == null)
				return null;
			int index = words.length - 1 - indexFromEnd;
			return (index < 0) ? null : words[index];
		}
	}

	private static String getHashSetKey(String word) {
		return word.toUpperCase(Locale.ROOT);
	}

	private static void initialize() {
	   frequentEnglishWords = initFrequentWords("frequent_words_english.txt", false);
	   frequentGermanWords = initFrequentWords("frequent_words_german.txt", true);
	   
	   frequentEnglishTypos = new HashMap<>();
	   frequentEnglishTypoCount = initFrequentCorrections("frequent_typos_english.txt", frequentEnglishTypos);
	   frequentBritishEnglish = new HashMap<>();
	   frequentBritishEnglishCount = initFrequentCorrections("frequent_british_english.txt", frequentBritishEnglish);
	   
	   nonEnglishAbapUpperCaseKeywords = initHashSet(new String[] {"BADI", "EQ", "NE", "LT", "LE", "GT", "GE", "CA", "CO", "CS", "NA", "CN", "NS", "CP", "NP", "EQUIV", "CONV", "REF", "COND", "SHORTDUMP", "BOOLC", "XSDBOOL", "LEFTPLUS", "LEFTSPACE", "RIGHTPLUS", "RIGHTSPACE", "XSD", "TIMEZONE", "INIT", "DIV", "MOD", "BOOLX", "BOOL", "XOR", "PF1", "PF2", "PF3", "PF4", "PF5", "PF6", "PF7", "PF8", "PF9", "PF01", "PF02", "PF03", "PF04", "PF05", "PF06", "PF07", "PF08", "PF09", "PF10", "PF11", "PF12", "PF13", "PF14", "PF15", "PF16", "PF17", "PF18", "PF19", "PF20", "PF21", "PF22", "PF23", "PF24", "RADIOBUTTON", "C", "N", "X", "P", "LOB", "CLOB", "BLOB", "AMDP", "CDS", "DDL", "RETURNCODE", "DATAINFO", "STATUSINFO", "TABLEVIEW", "TABSTRIP", "UTCLONG", "HDB", "SQLSCRIPT", "TEXTPOOL", "T000", "INT1", "INT2", "INT4", "INT8", "NUMC", "DEC", "CURR", "QUAN", "FLTP", "DECFLOAT16", "DECFLOAT34", "D16D", "D34D", "D16R", "D34R", "D16N", "D34N", "CLNT", "CUKY", "LANG", "DATS", "DATN", "SSTRING", "TIMS", "TIMN", "RAWSTRING", "ADABAS", "SYBASE", "DB2", "AS400", "DB6", "MSSQLNT", "ABS", "CEIL", "COALESCE", "LPAD", "LTRIM", "RTRIM", "CONCAT", "INSTR", "RPAD", "BINTOHEX", "HEXTOBIN", "UUID", "INITCAP", "MONTHNAME", "DAYNAME", "ADD_MONTHS", "DAYS_BETWEEN", "ADD_DAYS", "IS_VALID", "TZONE", "TSTMP", "TSTMP1", "TSTMP2", "TSTMPL", "UTCL", "PCRE", "D16S", "D34S", "STDDEV", "VAR", "AVG", "CORR", "NTILE", "SPANTREE", "BITFIELD", "DYNPRO", "ELSEIF", "ENDAT", "ENDCASE", "ENDCATCH", "ENDCLASS", "ENDDO", "ENDEXEC", "ENDFORM", "ENDFUNCTION", "ENDIF", "ENDINTERFACE", "ENDLOOP", "ENDMETHOD", "ENDMODULE", "ENDON", "ENDPROVIDE", "ENDREP", "ENDSELECT", "ENDWITH", "ENDTRY", "ENDWHILE", "ENDENHANCEMENT", "SQL", "NAMETAB", "EXEC", "REGEX", "SUBMATCHES", "FRAMES", "PF", "AMDPDB", "INFOTYPES", "RMC", "LLANG", "TRDIR", "TOPOFPAGE", "UTF", "MATCHCODE", "MODIF", "CHECKBOX", "LISTBOX", "CPI", "LPI", "FKEQ", "FKGE", "GKEQ", "GKGE", "KERNELINFO", "TRMAC", "NOWAIT", "SUBSCREEN", "ULINE", "BT", "NB", "TITLEBAR", "SWITCHSTATES", "STRANS", "SYNCPOINTS", "HASHVAL", "WEBRFC", "GPA", "SUBMODE", "RABAX", "OPCODE", "LISTLEVEL", "OBJMGR", "TRACELEVEL", "NODELETE", "TRIGGERLEVEL", "GC", "STEPTIME", "CDESTR", "INST", "OTR", "NR", "NONEX", "CLAS", "ATTR", "SRCENC", "DSTENC", "LEN", "POS", "CINFO", "AUX", "RC", "DBLOCK", "OMRT", "SY", "ENUM", "GAP", "VERI", "QUICKINFO", "RSYN", "ENDCHAIN"});
	   nonEnglishAbapLowerCaseKeywords = initHashSet(new String[] {"abs", "c", "class_constructor", "dats", "n", "int1", "int2", "int4", "int8", "p", "s", "subrc", "sy", "tims", "timestamp", "timestampl", "x", "xsdbool", "table_line"});
	   nonEnglishDdlLowerCaseKeywords = initHashSet(new String[] {"abap_system_timezone", "abap_user_timezone", "accesspolicy", "analytical_query", "bintohex", "calendar_operation", "calendar_shift", "column_total", "concat", "concat_with_space", "context_node_exists", "curr_to_decfloat_amount", "currency_conversion", "current_total", "datn_add_days", "datn_add_months", "datn_days_between", "dats_add_days", "dats_add_months", "dats_days_between", "dats_from_datn", "dats_is_valid", "dats_tims_to_tstmp", "dats_to_datn", "deviation_ratio", "fiscal_calendar_operation", "fiscal_calendar_shift", "fltp_to_dec", "get_cell_reference_value", "get_numeric_value", "grand_total", "hextobin", "hry_node_sign_value", "instr", "lpad", "ltrim", "nodetype", "optional_element_exists", "pfcg_filter", "pfcg_mapping", "ratio_of", "replace_regexpr", "row_total", "rpad", "rtrim", "sacf_check_in_use", "spantree", "switch_runtime_state", "tims_from_timn", "tims_is_valid", "tims_to_timn", "toggle_runtime_state", "transactional_interface", "transactional_query", "tstmp_add_seconds", "tstmp_current_utctimestamp", "tstmp_is_valid", "tstmp_seconds_between", "tstmp_to_dats", "tstmp_to_dst", "tstmp_to_tims", "tstmpl_from_utcl", "tstmpl_to_utcl", "unit_conversion", "utcl_add_seconds", "utcl_current", "utcl_seconds_between"});	   

		abapSeparators = initHashSet(new String[] {"=>", "( ", "->", " ).E", ">-", " <", "B<", " = <", "( ).E", " )E", "B( ", " #( ", "> ", "[ ", "(E", ") = ", ">.E", "( )->", "~", " ) ).E", " ?= ", "B!", " ) )E", ">E", ">->", " <> ", "( ) ).E", " ] ", " ) ) ).E", "( )E", " = -", " ]-", " ].E", " )->", " #(", " #( ( ", " ]E", "( )-", "+", "( ) ", " ##", "(<", " += ", " ]->", " ( ", ">).E", " += <", " <> <", " ( <", ": <", "( <", " #( <", " #( ).E", " ) ", ") = <", " + <", "B+ <", " #(E", " > ", " && ", "> ).E", ") ).E", " #( )E", " =E", ": / ", "( ( ", " * <", "( ) && ", "> = ", "( ) = ", "( ) )E", " < <", " #( ) ).E", " = ( ", " > <", " ] ).E", ">)E", " -= ", "> )->", " <= ", ") ) ).E", "> = <", " / <", ") && ", " - <", "[].E", " ) ( ", " ) = ", " >= ", " ) ) ", " ) ) )E", " #( (E", " ] )E", " ) * ", "( ) = <", "B= ", "( ) ) ).E", "[] ", ") < ", " ) ) ) ).E", " * -", "[", "B+ ", ": /.E", ":", "B( <", " = ( <", " ) ##", "B##", "> )E", ", <", " ) > ", "->* ", ">) ", "( ) )->", " ] ) ) ).E", "].E", " ) ) )->", " ] ) ).E", ") )E", "> <> <", " *= ", "[] ).E", " * ( ", " ) ) ) ) ).E", "[]E", " : ", "B* ( ", " ) <> ", " ( ( <", ") <= ", "]E", " = - ", "> ) ).E", ") >= ", "[] = ", " ( ( ", "B* <", " - ( ", "B* ( <", "> ) = ", ">) ##", "( ) ##", "B)->", ", /.E", ",", ") = ( ", " / ( ", "B- <", " *= ( ", "B= <", "> <> ", "B- ( ", "B/ ", " ) >= ", "( ) ) ", "\\", " ) + ", " && <", " ?= <", "]-", "( )=>", "( -", " ,E", ":<", "> < <", " *E", " ) / ", " +E", ") =E", " >= <", " <= <", " (E", " ,", " -= <", " ) =E", " :E", " ] ) ", "> ##", " * ( -", " ) ) ) ) ) ).E", ") = - ", " / -", ") ##", " /", "->(", " /= ", ") - ", ": /", ": / <", " /.E", "B).E", "B.E", "B)E"});
		ddlSeparators = initHashSet(new String[] {".", ",E", "B@", ": #", " = ", "(", " : ", "( ", "B}E", " ;E", " $", " [", " ) ", " ) ;E", "B{E", ":", " }E", ": { ", "B{ ", "B}]E", ": [E", "] ", "..", ": :", " ( ", ",", "}E", "..*] ", ": {", "]E", " )E", ": [", " = $", "(E", " <> ", "B) ", " : :", ": {E", " => ", "[", "].", ": $", "*", ": #(", ", #", ":{E", ")) ", " <= $", " >= ", " {E", " >= $", "B( ", " < $", " ]E", "B(E", ": [ #", " > ", " => $", " <= ", " = :", ": [#", " -", " + ", "B]E", " => :", ": [{E", " : $", "*(-", " < ", "($", "B},{E", "B{", "B} ", " > $", " (E", ": [ ", " ))E", ": [{", " =$", ") + ", "=$", "B:", "],E", " ),E", " },E", "+", ") ) ", "B} ,{E", "},E", ":{", "}]E", " ,E", " <= :", "(:", ":#", " ) )E", ": [ { ", "B$", ": [{ ", ") - ", " :", "( $", "}],E", "B],E", "B}}E", "(*) ", " }]E", ":[E", "))E", ", $", " < :", " } ]E", " >= :", " =", ":[#", "(( ", " ],E", " > :", " , ", " )", ", :", ">= ", "B}, {E", " * (-", ":[{", "= ", " ].", " ] }E", "B[", "((", "*-", ": [ {", ":{ ", " } }]E", "*$", ") / ", "( * ) ", " } ] }E", " } }E", " ,", "( (", ")) ) ", " ) - ", "B+ ", " ), ", " ) ) ", " } } ]E", "B\" ", " .", " @", " ) ), ", "(*) - ", ") * ", "= :", " [*] ", "[ ", " : {E", " != ", " ) * ", " * (", ") )", " ) * $", " } ],E", ") <= ", " ( (", "( :", " **/E", ") )E", ") {E", " ) ,E", "B* -E", ")*", "{E", " ),$", ":[", ", ( ", ",$", " * $"}); 
	   textInAbapSeparators = initHashSet(new String[] {" (", ". ", "/", "; ", "B! <", "=E", "..", ";E", " @ ", " ..", "% ", " & ", "), ", ".", "B! @", "...", "B(", "% / ", " #", "%E", "): ", "B... ", "..., ", " _", "B! ", "?E", " ...E", " # ", "% + ", "% * ", ")", " +", "):E", " ...", "); ", "B# ", " ... ", ")):E", "%, ", "% - ", "% = ", " *", ": (", "B..", "* ", "))E", "B--- ", " (= ", "!E", "*", "). ", "B---", "B----- ", "!)E", ");E", "%) ", ". (", "B-", "B=> ", " --> ", "/ ", " -> -", ". - ", ") - (", "+ ", "+)E", "- ", " [", "] ", "!!!E", "? ", "%) * ", " [+ ", ".) ", "(!) ", ") & ", "#", "B!!! ", " !!!E", "+E", "/_", "% / +", ") -> ", " :", ".)E", "*E", ": ..", "; ..", "B_", "***E", "B-----", "!!!!!!!!E", " :E", "B@", "B------ ", ")!!!E", "..E", ")!E", ", ..", ") ... ", "... ", "B*", " %E", " (=", "->...~", ") => ", " -> ..", "B<< ", "B>> "});
	   textInDdlSeparators = initHashSet(new String[] {". ", "/", "; ", "B! <", "=E", ";E", " @ ", " ..", "% ", " & ", "), ", "B! @", "...", "B(", "% / ", "%E", "): ", "B... ", "..., ", "B! ", "?E", " ...E", " # ", "% + ", "% * ", ")", "):E", " ...", "); ", "B# ", " ... ", "%, ", "% - ", "% = ", " *", ": (", "B..", "* ", " (= ", "!E", "). ", "!)E", ");E", "%) ", ". (", "B-", "B=> ", " --> ", "/ ", " -> -", ". - ", ") - (", "- ", "!!!E", "? ", "%) * ", ".) ", "(!) ", ") & ", "#", "B!!! ", " !!!E", "% / +", ") -> ", ".)E", "*E", ": ..", "; ..", "***E", "!!!!!!!!E", "B------ ", ")!!!E", "..E", ")!E", ", ..", ") ... ", "... ", "B*", " %E", " (=", "->...~", ") => ", " -> ..", "B<< ", "B>> "});
	   // ambiguousAbapSeparators = initHashSet(new string[] { ".E", "-", " = ", ") ", ",E", ": ", ").E", ") ", " - ", " / ", " + ", " * ", " < ", ", ", ")E", "B- ", "B* ", ", ", ":E", " -", "(", "),E", "B- ", "B* " });
	   // ambiguousDdlSeparators = initHashSet(new string[] { " ", ": ", ") ", ", ", " (", ")E", "B* ", "E", ";E", "B)E", "B*/E", "B-", ":E", ".E", "),", "),E", "), ", "B*E", " - ", "B- ", "/", "B(", " & ", " \"", ").E", " * ", "*/ " });

	   autoGeneratedAbapPrefixes = new String[] {"* <SIGNATURE>", "* | ", "* +-", "*&"};

	   abapLevelOpeners = initHashSet(new String[] {"INTERFACE", "CLASS", "PUBLIC", "PROTECTED", "PRIVATE", "METHOD", "DO", "WHILE", "LOOP", "AT", "IF", "ELSEIF", "ELSE", "CASE", "WHEN", "CATCH", "FORM", "FUNCTION", "MODULE", "TRY", "EXEC", "TEST-SEAM", "TEST-INJECTION", "DEFINE", "ENHANCEMENT", "ENHANCEMENT-SECTION", "PROVIDE", "ON" });
	   abapLevelClosers = initHashSet(new String[] {"ENDINTERFACE", "ENDCLASS", "PUBLIC", "PROTECTED", "PRIVATE", "ENDMETHOD", "ENDDO", "ENDWHILE", "ENDLOOP", "ENDAT", "ENDIF", "ELSEIF", "ELSE", "WHEN", "CATCH", "ENDFORM", "ENDFUNCTION", "ENDMODULE", "ENDTRY", "ENDCASE", "ENDEXEC", "END-TEST-SEAM", "END-TEST-INJECTION", "END-OF-DEFINITION", "ENDENHANCEMENT", "END-ENHANCEMENT-SECTION", "ENDPROVIDE", "ENDON" });
	   
		isInitialized = true;
	}

	private static HashSet<String> initFrequentWords(String resourceName, boolean isGerman) {
		HashSet<String> result = new HashSet<String>();

		InputStream resourceStream = CommentIdentifier.class.getClassLoader().getResourceAsStream(resourceName);
		if (resourceStream == null)
			return result;
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(resourceStream, StandardCharsets.UTF_8));
		
		try {
			String line;
			do {
				line = bufferedReader.readLine();
				if (line == null || line.length() == 0) 
					continue;

				String key = getHashSetKey(line);
				if (StringUtil.isNullOrEmpty(key))
					continue;

				if (!result.contains(key))
					result.add(key);
				
				// for German special characters, also add an ASCII version
				if (isGerman) {
					String lineUmlaut = line.replaceAll("\u00e4", "ae").replaceAll("\u00f6", "oe").replaceAll("\u00fc", "ue").replaceAll("\u00df", "ss");
					if (!lineUmlaut.equals(line)) {
						key = getHashSetKey(lineUmlaut);
						if (!result.contains(key))
							result.add(key);
					}
				}
			} while (line != null);

			bufferedReader.close();
		} catch (IOException e) {
		}

		return result;
	}

	private static int initFrequentCorrections(String resourceName, HashMap<String, String> map) {
		InputStream resourceStream = CommentIdentifier.class.getClassLoader().getResourceAsStream(resourceName);
		if (resourceStream == null)
			return 0;
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(resourceStream, StandardCharsets.UTF_8));
		
		int entryCount = 0;
		try {
			String line;
			do {
				line = bufferedReader.readLine();
				if (line == null || line.length() == 0) 
					continue;

				// read the next entry; note that the value (i.e. the correction) may be missing,  
				// if a word is sure to be wrong, but possible corrections are ambiguous
				int tabPos = line.indexOf('\t');
				String key = (tabPos < 0) ? line : line.substring(0, tabPos);
				String value = (tabPos < 0) ? "" : line.substring(tabPos + 1);
				if (StringUtil.isNullOrEmpty(key))
					continue;

				// put the entry in the supplied casing
				if (!map.containsKey(key)) {
					++entryCount;
					map.put(key, value);
				}

				// if the key is supplied in lower case, also add an upper case mapping for keys at sentence beginning
				if (key.length() > 1 && value.length() > 1 && Character.isLowerCase(key.charAt(0)) && key.indexOf(' ') < 0 && value.indexOf(' ') < 0) {
					String keyUpper = Character.toUpperCase(key.charAt(0)) + key.substring(1);
					String valueUpper = Character.toUpperCase(value.charAt(0)) + value.substring(1);
					// exclude adding upper case examples for "friday -> Friday" (where "Friday -> Friday" would be identical)  
					if (!map.containsKey(keyUpper) && !keyUpper.equals(valueUpper)) {
						map.put(keyUpper, valueUpper);
					}
				}
			} while (line != null);

			bufferedReader.close();
		} catch (IOException e) {
		}

		return entryCount;
	}

	private static HashSet<String> initHashSet(String[] texts) {
		HashSet<String> result = new HashSet<String>();
		for (String text : texts) {
			String key = getHashSetKey(text);
			if (!result.contains(key))
				result.add(key);
		}
		return result;
	}

	public static HashMap<String, String> getFrequentEnglishTypos() {
		if (!isInitialized) 
			initialize();
		return frequentEnglishTypos;
   }

   public static HashMap<String, String> getFrequentBritishEnglish() {
		if (!isInitialized) 
			initialize();
		return frequentBritishEnglish;
   }

	public static int getFrequentEnglishTypoCount() { 
		if (!isInitialized) 
			initialize();
		return frequentEnglishTypoCount; 
	}
	
	public static int getFrequentBritishEnglishCount() { 
		if (!isInitialized) 
			initialize();
		return frequentBritishEnglishCount; 
	}

	// -----------------------------------------------------------------------------------------------------------------
	
	public final String filterForMode(String text, CommentIdentifierMode mode, Language codeLanguage) {
		boolean allowLineStartComments = (mode == CommentIdentifierMode.LINE_START_COMMENTS
								    			 || mode == CommentIdentifierMode.ALL_COMMENT_LINES);

		boolean allowNonLineStartComments = (mode == CommentIdentifierMode.NON_LINE_START_COMMENTS
										 			 || mode == CommentIdentifierMode.ALL_COMMENT_LINES);
		
		String textTrim = StringUtil.trimStart(text);
		if (mode == CommentIdentifierMode.CODE_ONLY) {
         // only process lines that are sure to be ABAP Code
			if (codeLanguage == Language.ABAP) {
	         if (AbapCult.stringStartsWith(text, ABAP.LINE_COMMENT_SIGN_STRING)) { 
	            return null;
	         } else if (AbapCult.stringStartsWith(textTrim, ABAP.COMMENT_SIGN_STRING)) {
	            return null;
	         }
			} else if (codeLanguage == Language.DDL) {
	         if (textTrim.startsWith(DDL.LINE_END_COMMENT) || textTrim.startsWith(DDL.LINE_END_MINUS_COMMENT)
	         		|| textTrim.startsWith(DDL.ASTERISK_COMMENT_START)) {
	            return null;
	         }
			}
        	return text;

		} 
		
		if (allowLineStartComments) {
			if (codeLanguage == Language.ABAP && AbapCult.stringStartsWith(text, ABAP.LINE_COMMENT_SIGN_STRING)) {
				// text is a * comment line, as you get it when commenting out multiple lines of code
				return text;
			} else if (codeLanguage == Language.DDL && text.startsWith(DDL.LINE_END_COMMENT)) {
				// text starts with // with no spaces before it, as you would get it when commenting out multiple lines of code
				return text;
			}

		} 
		
		if (allowNonLineStartComments) {
         // if text is a " comment line ... 
         if (codeLanguage == Language.ABAP && textTrim.length() > 1 && textTrim.startsWith(ABAP.COMMENT_SIGN_STRING)) {
            // .. replace the comment sign " with *, otherwise the CommentIdentifier will realize that it is a " comment 
         	// (esp. with analyzeInnerComments == false)
            return ABAP.LINE_COMMENT_SIGN_STRING + textTrim.substring(1);

         } else if (codeLanguage == Language.DDL && !text.startsWith(DDL.LINE_END_COMMENT) && textTrim.length() > 2 && DDL.textStartsCommentAt(textTrim, 0)) {
            // .. replace the // or -- or /* comment sign with // at line start - otherwise the CommentIdentifier will 
         	// realize that it is a non-line-start comment (esp. with analyzeInnerComments == false)
            return ABAP.LINE_COMMENT_SIGN_STRING + textTrim.substring(2);
         
         } else {
            return null;
         }
		
		} else {
			return null;
		}
	}
	
	public final int identifyComments(String codeText, StringBuilder output, CommentIdentifierMode mode) {
		Language codeLanguage = Language.preview(codeText);
      String[] lines = StringUtil.split(codeText, ABAP.LINE_SEPARATOR, false);

      if (output != null)
         output.append("Line number\tCode\tDecision\tCodeProbability %\tpro Code\tpro Text\tReasons").append(System.lineSeparator());

      String prevText = null;
      int count = 0;
      for (int i = 0; i < lines.length; ++i) {
         String text = lines[i];
         if (StringUtil.isNullOrEmpty(text))
            continue;
         
         text = filterForMode(text, mode, codeLanguage);
         if (text == null)
         	continue;

         String nextText = (i + 1 < lines.length) ? lines[i + 1] : null;

         CommentIdentification identification = identifyComment(text, false, prevText, nextText, true, codeLanguage);
         ++count;

         if (output != null) {
            output.append(String.valueOf(i));
            output.append('\t').append(" " + text);
            output.append('\t').append(identification.canDecide() ? (identification.isCode() ? "Code" : "Text") : "unknown");
            output.append('\t').append(String.valueOf(identification.getCodeProbabilityPercent()));
            output.append('\t').append(String.valueOf(identification.reasonsProCode));
            output.append('\t').append(String.valueOf(identification.reasonsProText));
            output.append('\t').append(" " + identification.getReasonsWithSep(" "));
            output.append(System.lineSeparator());
         }
         prevText = text;
      }
      return count;
   }

	public final CommentIdentification identifyComment(String lineText, boolean analyzeInnerComments, Language codeLanguage) {
		return identifyComment(lineText, analyzeInnerComments, null, null, false, codeLanguage);
	}
	public final CommentIdentification identifyComment(String lineText, boolean analyzeInnerComments, String prevLineText, String nextLineText, boolean provideReasons, Language codeLanguage) {
		// lazy instantiation of static dictionaries (including for the sake of the test suite)
		if (!isInitialized) {
			initialize();
		}
		
		final String lineSep = System.lineSeparator();
		final String proCodePrefix = "+ ";
		final String proTextPrefix = "- ";

		StringBuilder reasons = provideReasons ? new StringBuilder() : null;

		int proCode = 0;
		int proText = 0;
		int proEnglish = 0;
		int proGerman = 0;

		if (codeLanguage == Language.ABAP) {
			for (String autoGeneratedPrefix : autoGeneratedAbapPrefixes) {
				if (AbapCult.stringStartsWith(lineText, autoGeneratedPrefix)) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "line seems to be auto-generated as it starts with '" + autoGeneratedPrefix + "'");
					return new CommentIdentification(proCode, proText, proEnglish, proGerman, -1, reasons, null, true);
				}
			}
			if (AbapCult.stringStartsWith(lineText, "***")) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "line starts with three or more '***'");
				return new CommentIdentification(proCode, proText, proEnglish, proGerman, -1, reasons, null, false);
			}
		}
		
		Line line = preprocessLine(lineText, analyzeInnerComments, codeLanguage);
		int indent = line.indent;
		// if (line == null)
		// 	return new CommentIdentification(proCode, proText, indent, reasons, line.words);

		// analyzeInnerComments depends on the context:
		// - for the CommentTypeRule, a quotation mark " comment is regarded as part of ABAP code and therefore 
		//   not analyzed further (analyzeInnerComments == false)
		// - for the TypoRule, " comments get a 'deep analysis' to determine whether they are textual English or German
		//   (analyzeInnerComments == true)
		if (line.isInnerCommentLine && !analyzeInnerComments) {
			++proCode;
			if (reasons != null)
				reasons.append(proCodePrefix + "line starts inner comment");
			return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);

		} else if (line.getWordCount() == 0 && line.getSeparatorCount() == 1) {
			if (AbapCult.stringStartsWith(line.separators[0], "B---")) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "line starts with three or more '---'");
				indent = -1;
				return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);
			
			} else if (AbapCult.stringStartsWith(line.separators[0], "B===")) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "line starts with three or more '==='");
				indent = -1;
				return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);
		
			} else if (AbapCult.stringStartsWith(line.separators[0], "B***")) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "line starts with three or more '***'");
				indent = -1;
				return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);
			}
		}
		Line prevLine = preprocessLine(prevLineText, analyzeInnerComments, codeLanguage);
		Line nextLine = preprocessLine(nextLineText, analyzeInnerComments, codeLanguage);

		for (int i = 0; i < line.getWordCount(); ++i) {
			String word = line.words[i];
			boolean mayBeKeyword = line.wordsMayBeKeywords.get(i);
			if (StringUtil.isNullOrEmpty(word)) // pro forma
				continue;

			boolean containsLetters = !AbapCult.toUpper(word).equals(AbapCult.toLower(word));
			boolean isAllUpper = word.toUpperCase().equals(word);
			boolean isAllUpperOrAllLower = isAllUpper || word.toLowerCase().equals(word);
			boolean startsWithUpper = Character.isUpperCase(word.charAt(0));
			boolean isAllLowerFromSecondChar = word.length() >= 2 && word.substring(1).equals(AbapCult.toLower(word.substring(1)));
			boolean hasFirstUpperOnly = containsLetters && word.length() >= 2 && startsWithUpper && isAllLowerFromSecondChar;
			boolean hasInnerUpperCase = !isAllUpperOrAllLower && startsWithUpper && !isAllLowerFromSecondChar;

			if (codeLanguage == Language.ABAP && hasFirstUpperOnly) {
				++proText;
				if (reasons != null) 
					reasons.append(proTextPrefix + "capitalized word '" + word + "'").append(lineSep);
			}

			if (codeLanguage == Language.ABAP && mayBeKeyword && ABAP.isAbapUpperCaseKeyword(word)) {
				if (AbapCult.toUpper(word).equals(word)) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "upper case ABAP keyword '" + word + "'").append(lineSep);
				} else {
					++proText;
					if (reasons != null)
						reasons.append(proTextPrefix + "ABAP keyword '" + word + "' in lower case").append(lineSep);
				}
				if (nonEnglishAbapUpperCaseKeywords.contains(getHashSetKey(word))) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "ABAP keyword '" + word + "'").append(lineSep);
				}

			} else if (codeLanguage == Language.ABAP && mayBeKeyword && ABAP.isAbapLowerCaseKeyword(word)) {
				if (AbapCult.toLower(word).equals(word)) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "lower case ABAP keyword '" + word + "'").append(lineSep);
				} else {
					++proText;
					if (reasons != null)
						reasons.append(proTextPrefix + "ABAP keyword '" + word + "' in upper case").append(lineSep);
				}
				if (nonEnglishAbapLowerCaseKeywords.contains(getHashSetKey(word))) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "ABAP keyword '" + word + "'").append(lineSep);
				}

			} else if (codeLanguage == Language.DDL && mayBeKeyword && (DDL.isDdlKeyword(word) || DDL.isDclKeyword(word) || DDL.isBuiltInDdlFunction(word) || DDL.isBuiltInDclFunction(word))) {
				if (word.toLowerCase().equals(word)) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "lower case DDL keyword or built-in function '" + word + "'").append(lineSep);
				} else {
					++proText;
					if (reasons != null)
						reasons.append(proTextPrefix + "DDL keyword or built-in function '" + word + "' with upper case char").append(lineSep);
				}
				if (nonEnglishDdlLowerCaseKeywords.contains(getHashSetKey(word))) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "DDL keyword or built-in function '" + word + "'").append(lineSep);
				}

			} else if (codeLanguage == Language.DDL && hasInnerUpperCase) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + "CamelCase identifier '" + word + "'").append(lineSep);

			} else if (codeLanguage == Language.ABAP && containsLetters && word.length() >= 2 && AbapCult.toUpper(word).equals(word) && !ABAP.isAbapUpperCaseKeyword(word)) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "upper case word '" + word + "' is not an ABAP keyword").append(lineSep);

			} else if (mayBeKeyword && frequentEnglishWords.contains(getHashSetKey(word)) && (codeLanguage == Language.ABAP || !isAllUpper)) {
				// for DDL, do NOT consider upper case words here, because they frequently appear as enumeration values in annotations, e.g. CHECK, REQUIRED, TRANSACTIONAL etc.
				++proText;
				++proEnglish;
				if (reasons != null)
					reasons.append(proTextPrefix + "non-code English word '" + word + "'").append(lineSep);

			} else if (mayBeKeyword && frequentGermanWords.contains(getHashSetKey(word))) {
				++proText;
				++proGerman;
				if (reasons != null)
					reasons.append(proTextPrefix + "non-code German word '" + word + "'").append(lineSep);

			} else if (mayBeKeyword && frequentEnglishTypos.containsKey(word)) {
				++proText;
				++proEnglish;
				if (reasons != null)
					reasons.append(proTextPrefix + "non-code English typo '" + word + "'").append(lineSep);

			} else if (mayBeKeyword && frequentBritishEnglish.containsKey(word)) {
				++proText;
				++proEnglish;
				if (reasons != null)
					reasons.append(proTextPrefix + "non-code British English '" + word + "'").append(lineSep);

			} else if (mayBeKeyword && StringUtil.indexOfAny(word, GERMAN_SPECIAL_CHARS, 0) >= 0) {
				++proText;
				++proGerman;
				if (reasons != null)
					reasons.append(proTextPrefix + "non-code word with German special char '" + word + "'").append(lineSep);

			} else {
				if (word.indexOf('_') >= 0) {
					++proCode;
					if (reasons != null)
						reasons.append(proCodePrefix + "underscore(s) in '" + word + "'").append(lineSep);
				}
				int apostrophePos = word.indexOf('\'');
				if (apostrophePos > 0 && apostrophePos + 1 < word.length()) {
					++proText;
					if (reasons != null)
						reasons.append(proTextPrefix + "apostrophe inside '" + word + "'").append(lineSep);
				}
			}
		}

		String lastSep = null;
		int sepCount = line.getSeparatorCount();
		for (int sepIndex = 0; sepIndex < sepCount; ++sepIndex) {
			String sep = line.separators[sepIndex];
			if (codeLanguage == Language.ABAP && lastSep != null && AbapCult.stringEndsWith(lastSep, "<") && AbapCult.stringStartsWith(sep, ">")) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + "field-symbol identifier <...>");
			}

			String key = getHashSetKey(sep);
			if (codeLanguage == Language.ABAP && abapSeparators.contains(key)) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + "typical ABAP separator '" + sep + "'").append(lineSep);
			} else if (codeLanguage == Language.DDL && ddlSeparators.contains(key)) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + "typical DDL separator '" + sep + "'").append(lineSep);
			} else if (codeLanguage == Language.ABAP && textInAbapSeparators.contains(key)
						|| codeLanguage == Language.DDL && textInDdlSeparators.contains(key)) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "typical text separator '" + sep + "'").append(lineSep);
			}

			if (codeLanguage == Language.ABAP && sepIndex + 1 < line.separators.length && sep.startsWith(ABAP.DOT_SIGN_STRING)) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "period . inside line").append(lineSep);
			}

			if (codeLanguage == Language.ABAP && sepIndex >= 2 && sep.startsWith(ABAP.COLON_SIGN_STRING)) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "colon : inside line").append(lineSep);
			}

			if (separatorFrequency.containsKey(key))
				separatorFrequency.put(key, separatorFrequency.get(key) + 1);
			else
				separatorFrequency.put(key, 1);

			lastSep = sep;
		}

		if (codeLanguage == Language.ABAP && prevLine != null) {
			int indentChange = prevLine.expectedIndentChangeForNextAbapLine();
			if (indentChange != 0 && prevLine.indent + indentChange == line.indent) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + getIndentChangeInfo(indentChange) + " after " + prevLine.words[0]);
			}
			indentChange = line.expectedIndentChangeForThisAbapLine();
			if (indentChange != 0 && prevLine.indent + indentChange == line.indent) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + getIndentChangeInfo(indentChange) + " with " + line.words[0]);
			}
		}

		if (codeLanguage == Language.ABAP && nextLine != null) {
			int indentChange = line.expectedIndentChangeForNextAbapLine();
			if (indentChange != 0 && line.indent + indentChange == nextLine.indent) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + getIndentChangeInfo(indentChange) + " after " + line.words[0]);
			}
			indentChange = nextLine.expectedIndentChangeForThisAbapLine();
			if (indentChange != 0 && line.indent + indentChange == nextLine.indent) {
				++proCode;
				if (reasons != null)
					reasons.append(proCodePrefix + getIndentChangeInfo(indentChange) + " with " + nextLine.words[0]);
			}
		}

		if (codeLanguage == Language.DDL && StringUtil.equalsCheckingForNull("B@", line.getSep(0)) && StringUtil.equalsCheckingForNull(".", line.getSep(1))) {
			++proCode;
			if (reasons != null)
				reasons.append(proCodePrefix + "typical annotation line start: '@<word>.<word>");
		}

		if (codeLanguage == Language.DDL && StringUtil.equalsCheckingForNull(",E", line.getSepFromEnd(0)) && StringUtil.equalsCheckingForNull("as", line.getWordFromEnd(1))) {
			++proCode;
			if (reasons != null)
				reasons.append(proCodePrefix + "typical element line end: '... as <word>,'");
		}

		// if nothing was detected, consider some special cases
		if (proCode == 0 && proText == 0) {
			String comment = line.comment;
			if (codeLanguage == Language.ABAP && textStartsWithActualQuote(comment)) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "comment sign seems to start a quote");
				return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);
			}

			if (codeLanguage == Language.ABAP && AbapCult.stringStartsWith(lineText, "**")) {
				++proText;
				if (reasons != null)
					reasons.append(proTextPrefix + "line starts with two '**'");
				return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);
			}

			// nothing was detected; make the decision depend on the previous or next line
			if (!StringUtil.isNullOrEmpty(prevLineText)) {
				CommentIdentification prevResult = identifyComment(prevLineText, analyzeInnerComments, codeLanguage);
				if (prevResult.canDecide()) {
					if (reasons != null)
						reasons.append("decision based on previous line");
					return new CommentIdentification(prevResult.reasonsProCode, prevResult.reasonsProText, prevResult.reasonsProEnglish, prevResult.reasonsProGerman, indent, reasons, line.words, false);
				}
			}
			if (!StringUtil.isNullOrEmpty(nextLineText)) {
				CommentIdentification nextResult = identifyComment(nextLineText, analyzeInnerComments, codeLanguage);
				if (nextResult.canDecide()) {
					if (reasons != null)
						reasons.append("decision based on next line");
					return new CommentIdentification(nextResult.reasonsProCode, nextResult.reasonsProText, nextResult.reasonsProEnglish, nextResult.reasonsProGerman, indent, reasons, line.words, false);
				}
			}

			// if nothing helps, make the caller decide, e.g. depending on the wider context
		}

		return new CommentIdentification(proCode, proText, proEnglish, proGerman, indent, reasons, line.words, false);
	}

	/**
	 * Returns the separators found between words in the comment lines that were processed since the last call to .resetSeparatorFrequencies()
	 * 
	 * @return
	 */
	public final String getSeparatorFrequencies() {
		final String lineSep = System.lineSeparator();
		StringBuilder result = new StringBuilder();
		result.append("separator (space added in front)\tfrequency").append(lineSep);
		for (Map.Entry<String, Integer> kvp : separatorFrequency.entrySet())
			result.append(" " + kvp.getKey() + "\t" + String.valueOf(kvp.getValue())).append(lineSep);
		return result.toString();
	}

	public final void resetSeparatorFrequencies() {
		separatorFrequency.clear();
	}

	private static Line preprocessLine(String text, boolean analyzeInnerComments, Language codeLanguage) {
		final String separatorDelimiters = (codeLanguage == Language.ABAP) ? ABAP.COMMENT_SIGN_STRING + ABAP.QUOT_MARK_STRING + ABAP.QUOT_MARK2_STRING + ABAP.PIPE_STRING + ABAP.BRACE_CLOSE_STRING
				 																				 : DDL.QUOT_MARK_STRING + DDL.UNDERSCORE_STRING;
		final String allowedCharsInWord = "_-'";
		final String allowedCharsAfterKeyword = (codeLanguage == Language.ABAP) ? " .:(" : " ("; // possibly, add [] for DDL

		if (text == null)
			return null;

		int pos = 0;
		if (codeLanguage == Language.ABAP) {
			while (pos < text.length() && text.charAt(pos) == ABAP.LINE_COMMENT_SIGN) {
				++pos;
			}
		} else if (codeLanguage == Language.DDL) {
			if (StringUtil.containsAt(text, pos, DDL.LINE_END_COMMENT)) {
				pos += DDL.LINE_END_COMMENT.length();
			} else if (StringUtil.containsAt(text, pos, DDL.LINE_END_MINUS_COMMENT)) {
				pos += DDL.LINE_END_MINUS_COMMENT.length();
			} else if (StringUtil.containsAt(text, pos, DDL.ASTERISK_COMMENT_START)) {
				pos += DDL.ASTERISK_COMMENT_START.length();
			}
		}
		if (pos > 0) {
			text = text.substring(pos);
		}
		
		int lineCommentSignCount = pos;

		int textLengthWithLeftSpaces = text.length();
		text = StringUtil.trimStart(text);
		int indent = StringUtil.isNullOrEmpty(text) ? -1 : lineCommentSignCount + textLengthWithLeftSpaces - text.length();

		// see .identifyComment() for an explanation of analyzeInnerComments
		if (codeLanguage == Language.ABAP && text.startsWith(ABAP.COMMENT_SIGN_STRING) && !analyzeInnerComments) {
			// this may be a text comment which just happens to have a "quote" at the beginning of the line
			if (!textStartsWithActualQuote(text)) {
				// otherwise consider the whole line as a " comment
				return new Line(indent, "", text, null, null, null, true);
			}
		} else if (codeLanguage == Language.DDL && DDL.textStartsCommentAt(text, 0)) {
			// otherwise consider the whole line as a //, --, or /* comment
			return new Line(indent, "", text, null, null, null, true);
		}

		// identify words, excluding: 
		// - in ABAP: literals in '...', |...|, |...{, }...|, as well as line-end comments "
		// - in DDL: literals in '...', as well as line-end comments starting with //, --, /*
		ArrayList<String> words = new ArrayList<String>();
		BitSet wordsMayBeKeywords = new BitSet();
		ArrayList<String> separators = new ArrayList<String>();
		String comment = "";

		int readPos = 0;
		boolean isFirstSep = true;
		while (readPos < text.length()) {

			// read separator
			StringBuilder separator = new StringBuilder();
			char lastSepChar = '\0';
			while (readPos < text.length() && !Character.isLetterOrDigit(text.charAt(readPos)) && separatorDelimiters.indexOf(text.charAt(readPos)) < 0) {
				if (codeLanguage == Language.DDL && DDL.textStartsCommentAt(text, readPos)) {
					break;
				} 
				char curSepChar = text.charAt(readPos);
				if (!(lastSepChar == ' ' && curSepChar == ' '))
					separator.append(curSepChar);
				lastSepChar = curSepChar;
				++readPos;
			}

			// add separator, but remove spaces before a line-end comment
			String sep = separator.toString();
			if (isFirstSep && !StringUtil.isNullOrEmpty(sep))
				sep = SEP_AT_LINE_START_MARK + sep;
			if (readPos == text.length()) {
				if (!StringUtil.isNullOrEmpty(sep))
					sep += SEP_AT_LINE_END_MARK;
			} else if ( codeLanguage == Language.ABAP && text.charAt(readPos) == ABAP.COMMENT_SIGN
						|| codeLanguage == Language.DDL && DDL.textStartsCommentAt(text, readPos)) {
				sep = StringUtil.trimEnd(sep) + SEP_AT_LINE_END_MARK;
			}
			if (!StringUtil.isNullOrEmpty(sep))
				separators.add(sep.toString());
			isFirstSep = false;

			if (readPos == text.length())
				break;

			char curChar = text.charAt(readPos);
			if (  codeLanguage == Language.ABAP && curChar == ABAP.COMMENT_SIGN
				|| codeLanguage == Language.DDL && DDL.textStartsCommentAt(text, readPos)) {
				// normal comment: the rest of the line
				comment = text.substring(readPos);
				break;

			} else if (codeLanguage == Language.ABAP && curChar == ABAP.QUOT_MARK) {
				// string literal with ': the whole literal
				readPos = skipUntil(text, readPos, abapStringEndChars, abapStringEscapeChar);

			} else if (codeLanguage == Language.ABAP && curChar == ABAP.QUOT_MARK2) {
				// string literal with `: the whole literal
				readPos = skipUntil(text, readPos, abapStringEndChars2, abapString2EscapeChar);

			} else if (codeLanguage == Language.ABAP && curChar == ABAP.PIPE || text.charAt(readPos) == ABAP.BRACE_CLOSE) {
				// string template with |: the whole template until | or {
				readPos = skipUntil(text, readPos, abapStringTemplateEndChars, abapStringTemplateEscapeChar);

			} else if (codeLanguage == Language.DDL && curChar == DDL.QUOT_MARK) {
				// string literal with ': the whole literal
				readPos = skipUntil(text, readPos, ddlStringEndChars, ddlStringEscapeChar);

			} else {
				// normal word
				int wordStart = readPos;
				// ABAP keywords are preceded by a space, while DDL keywords may be attached to the previous separator
				boolean mayBeKeyword = (codeLanguage == Language.DDL) ? true : (readPos == 0) || text.charAt(readPos - 1) == ' ';

				while (readPos < text.length() && (Character.isLetterOrDigit(text.charAt(readPos)) || allowedCharsInWord.indexOf(text.charAt(readPos)) >= 0
						|| (text.charAt(readPos) == '.' && readPos + 1 < text.length() && Character.isDigit(text.charAt(readPos + 1))))) {
					++readPos;
				}
				if (mayBeKeyword && readPos < text.length()) {
					if (allowedCharsAfterKeyword.indexOf(text.charAt(readPos)) < 0) {
						mayBeKeyword = false;

					} else if (codeLanguage == Language.ABAP) {
						int testPos = readPos;
						while (testPos < text.length() && text.charAt(testPos) == ' ') {
							++testPos;
						}
						if (AbapCult.stringContainsAt(text, testPos, "= ", false) || AbapCult.stringContainsAt(text, testPos, "TYPE ", true)) {
							mayBeKeyword = false;
						}
					}
				}
				if (readPos > wordStart) {
					String newWord = text.substring(wordStart, readPos);
					// for field symbols, include the pointed brackets <...> (even though they are also entered as separators)
					if (codeLanguage == Language.ABAP && wordStart > 0 && readPos < text.length() && text.charAt(wordStart - 1) == '<' && text.charAt(readPos) == '>' && Character.isLetter(text.charAt(wordStart)))
						newWord = "<" + newWord + ">";
					words.add(newWord);
					wordsMayBeKeywords.set(words.size() - 1, mayBeKeyword);
				}
			}
		}
		
		return new Line(indent, text, comment, words.toArray(new String[0]), wordsMayBeKeywords, separators.toArray(new String[0]));
	}

	/**
	 * Returns true if the supplied text may only incidentally look like a comment, 
	 * but actually seems to be textual (English / German) and just happens to start with a "quote".
	 */
	private static boolean textStartsWithActualQuote(String text) {
		if (!StringUtil.isNullOrEmpty(text) && text.length() >= 3 && Character.isLetterOrDigit(text.charAt(1))) {
			// the text looks like a quote, if there is a final " which is NOT preceded by a space and NOT directly followed by a letter or digit
			int quotEndPos = text.indexOf(ABAP.COMMENT_SIGN, 1);
			return (quotEndPos > 1 && text.charAt(quotEndPos - 1) != ' ' && (quotEndPos + 1 == text.length() || !Character.isLetterOrDigit(text.charAt(quotEndPos + 1))));
		}
		return false;
	}

	private static int skipUntil(String text, int readPos, char[] endChars, char escapeChar) {
		int wordEnd = StringUtil.indexOfAny(text, endChars, readPos + 1, escapeChar);
		return (wordEnd < 0) ? text.length() : wordEnd + 1;
	}

	public static String getScopeDescription(CommentIdentifierMode mode) {
		switch (mode) {
			case CODE_ONLY:
				return " for code lines";
			case NON_LINE_START_COMMENTS:
				return " for non-line-start comment lines";
			case LINE_START_COMMENTS:
				return " for line-start comment lines";
			case ALL_COMMENT_LINES:
				return " for all comment lines";
			default:
				throw new IndexOutOfBoundsException("unexpected CommentIdentifierMode!");
		}
	}
	
	private static String getIndentChangeInfo(int indentChange) {
		return "indent " + (indentChange > 0 ? "+" : "") + String.valueOf(indentChange);
	}

	public void addCommentSamples(String[] lines, CommentIdentifierMode mode, Language codeLanguage) {
      for (String line : lines) {
         if (StringUtil.isNullOrEmpty(line))
            continue;

         // skip lines that do not match the filter
         String text = filterForMode(line, mode, codeLanguage);
         if (text == null)
         	continue;

         // skip lines that are currently rated as code
         CommentIdentification identification = identifyComment(text, true, null, null, false, codeLanguage);
         if (identification.isCode())
         	continue;

         // skip certain lines completely
         if (codeLanguage == Language.ABAP) {
	         boolean skipLine = false;
	         for (String skipText : wordFreqSkipAbapTexts) {
	         	if (text.indexOf(skipText) >= 0) {
	         		skipLine = true;
	         		break;
	         	}
	         }
	         if (skipLine) {
	         	continue;
	         }

	         // remove typical ABAP Doc tags  
	         for (String removeText : wordFreqRemoveAbapTexts) {
	            text = text.replace(removeText, "");
	         }

	         // skip ABAP Doc parameter and exception names  
	         if (text.indexOf("@parameter") >= 0 || text.indexOf("@raising") >= 0) {
	         	int pos = text.indexOf('|');
	         	if (pos < 0)
	         		continue;
	      		text = (pos + 1 == text.length()) ? "" : text.substring(pos + 1);
	         };
         }
         
         StringBuilder sbWords = new StringBuilder();
         sbWords.append(identification.isEnglish() ? ENGLISH_LINE_PREFIX : GERMAN_LINE_PREFIX);
         TextReader textReader = TextReader.createForComment(text);
         do {
         	String word = textReader.getNextWord();
         	if (word == null)
         		break;
         	
        		sbWords.append(' ');
         	if (isTextualWord(word, codeLanguage)) {
	         	sbWords.append(word);
         	} else {
         		// add a placeholder to show in the example text that there was 'some identifier' etc. in this place
         		sbWords.append(NON_TEXTUAL_WORD);
         	}
         } while(true);

         // the line is now 'simplified', i.e. reduced to valid words (or '_' as placeholders for non-valid words)
         // and separated by spaces; this is now entered to a HashSet, so identical lines that are auto-generated  
         // or copied a lot are only counted once
         lineSamples.add(sbWords.toString());
      }
	}
	
	private boolean isTextualWord(String word, Language codeLanguage) {
   	if (StringUtil.indexOfAny(word, wordFreqSkipChars, 0) >= 0) {
      	// words that contain /, #, _, <, >, or any digit are NOT regarded as textual
   		return false;
   	} else if (word.toUpperCase().equals(word)) {
   		// words in capitals are probably ABAP words or abbreviations
   		return false;
   	}
   	
   	// words in CamelCase are probably identifiers 
   	for (int i = 1; i < word.length(); ++i) {
   		if (Character.isUpperCase(word.charAt(i)) && Character.isLowerCase(word.charAt(i - 1))) { 
      		return false;
   		}
   	}
   	
   	// words that start or end with - are not considered textual
   	if (word.startsWith("-") || word.endsWith("-"))
   		return false;

   	// words that start with sy- or syst- are ABAP identifiers
   	if (codeLanguage == Language.ABAP && (word.startsWith("sy-") || word.startsWith("SY-") || word.startsWith("syst-") || word.startsWith("SYST-")))
   		return false;
   	
   	return true;
	}

	public String getWordFrequencies(String oldTable) {
		HashMap<String, WordFrequency> freqOfWords = new HashMap<>();
		return getWordFrequencies(oldTable, freqOfWords);
	}

	String getWordFrequencies(String oldTable, HashMap<String, WordFrequency> freqOfWords) {
		final String ENGLISH = "E";
		final String GERMAN = "D";
		final String OCCURRENCE_START = "#";
		final String OCCURRENCE_END = "#";
		final int STANDARDIZED_SAMPLE_SIZE = 10000000; // 10 million

		// create a HashMap of word frequencies
		for (String lineSample : lineSamples) {
			String[] words = StringUtil.split(lineSample, ' ', true);
			boolean isFirst = true;
			boolean isGerman = false;
			for (String word : words) {
				// the first 'word' is the language prefix 'E' or 'D'
				if (isFirst) {
					isGerman = word.equals(GERMAN_LINE_PREFIX);
					isFirst = false;
					continue;
				}
				if (word.equals(NON_TEXTUAL_WORD))
					continue;
				if (freqOfWords.containsKey(word)) {
					WordFrequency freq = freqOfWords.get(word);
					freq.count++;
				} else {
					freqOfWords.put(word, new WordFrequency(isGerman, lineSample));
				}
			}
		}
		
		// determine the total word count
		int totalWordCount = 0;
		for (String word : freqOfWords.keySet()) {
			WordFrequency freq = freqOfWords.get(word);
			totalWordCount += freq.count;
			freq.countUpperAndLower = freq.count;
		}
		double freqFac = STANDARDIZED_SAMPLE_SIZE / (double)totalWordCount;
		
		// determine the combined frequency count for a word in upper and lower case
		for (String word : freqOfWords.keySet()) {
			if (!Character.isUpperCase(word.charAt(0))) 
            continue;
			WordFrequency freqUpper = freqOfWords.get(word);
			WordFrequency freqLower = freqOfWords.get(word.toLowerCase());
         if (freqUpper != null && freqLower != null) {
            freqLower.countUpperAndLower += freqUpper.count;
            freqUpper.countUpperAndLower += freqLower.count;
         }
      }

		// create a HashMap of the old table which was read from the clipboard (if any) 
		HashMap<String, String> oldLineOfWord = new HashMap<>();
		String oldCategoriesHeader = null;
		if (!StringUtil.isNullOrEmpty(oldTable) ) {
			String[] oldLines = StringUtil.split(oldTable, new char[] { '\r', '\n' }, true);
			for (String oldLine : oldLines) {
				String[] oldCells = StringUtil.split(oldLine, '\t', false);
				if (oldCells.length < 13) 
					continue;
				String word = oldCells[5];
				if (oldCategoriesHeader == null) { 
					// keep the "categories" header from the header line
					oldCategoriesHeader = oldCells[4];
				} else if (!StringUtil.isNullOrEmpty(word)) {
					oldLineOfWord.put(word, oldLine);
				}
			}
		}
		
		StringBuilder sbResult = new StringBuilder();

		// write header
		sbResult.append("categorized");
		sbResult.append('\t').append("spellchecked");
		sbResult.append('\t').append("occurrences per " + String.valueOf(STANDARDIZED_SAMPLE_SIZE / 1E6) + " million words (from sample of " + Cult.format(totalWordCount) + " words)");
		sbResult.append('\t').append("occurrences UCASE + lcase");
		sbResult.append('\t').append((oldCategoriesHeader == null) ? "category" : oldCategoriesHeader);

		sbResult.append('\t').append("word");
		sbResult.append('\t').append("correction");
		sbResult.append('\t').append("casing (0 = lcase; 1 = UCASE of lcase; 2 = UCASE only; 3 = should be UCASE only, but lcase was found, too)");
		sbResult.append('\t').append("language");
		
		sbResult.append('\t').append("English frequent");
		sbResult.append('\t').append("German frequent");
		sbResult.append('\t').append("ABAP word");
		sbResult.append('\t').append("DDL word");
		sbResult.append('\t').append("first context");
		sbResult.append(System.lineSeparator());

		for (String word : freqOfWords.keySet()) {
			WordFrequency freq = freqOfWords.get(word);
			
			// determine casing: 
			// * 0 = word is lower case 
			// * 1 = word is upper case, but was also found in lower case
			// * 2 = word is upper case and was never found in lower case 
         String casing = "0";
         if (Character.isUpperCase(word.charAt(0))) {
            casing = freqOfWords.containsKey(word.toLowerCase()) ? "1" : "2";
         }

			// determine language(s) of the word: "E", "D" or "ED" (e.g. "in" which could be both English and German)
			// if the word is unknown to existing word lists, use the suspected language of the context
			boolean isFreqEnglish = frequentEnglishWords.contains(getHashSetKey(word));
			boolean isFreqGerman = frequentGermanWords.contains(getHashSetKey(word));
			String language = (isFreqEnglish ? ENGLISH : "") + (isFreqGerman ? GERMAN : "");
			if (language.length() == 0) 
				language = freq.isGerman ? GERMAN : ENGLISH;

			// determine context of first occurrence, highlighting the #word# in the context
			String context = freq.firstContext;
			int pos = StringUtil.findWholeWord(context, word, false, null);
			if (pos >= 0) {
				int end = pos + word.length();
				context = context.substring(0, pos) + OCCURRENCE_START + context.substring(pos, end) + OCCURRENCE_END + context.substring(end);
			}

			// get existing line, if any, then remove it from the HashMap, so remaining entries can be added at the end
			String oldLine = oldLineOfWord.get(word);
			boolean hasOld = !StringUtil.isNullOrEmpty(oldLine);
			if (hasOld) 
				oldLineOfWord.remove(word);
			String[] oldCells = hasOld ? StringUtil.split(oldLine, '\t', false) : null;
			boolean wasOldCategorized = hasOld && oldCells[0] == "1";
			// boolean wasOldSpellchecked = hasOld && oldCells[1] == "1";
			
			// the existing line is used (if any), but occurrence counts, 'casing', 'ABAP word', and 'context' are updated;
			// old 'language' information is only used if the old line was already categorized
			sbResult.append(hasOld ? oldCells[0] : "");                // categorized
			sbResult.append('\t').append(hasOld ? oldCells[1] : "");   // spellchecked
			sbResult.append('\t').append(String.valueOf(Math.round(freq.count * freqFac)));
			sbResult.append('\t').append(String.valueOf(Math.round(freq.countUpperAndLower * freqFac)));
			sbResult.append('\t').append(hasOld ? oldCells[4] : "");   // category
			
			sbResult.append('\t').append(word);
			sbResult.append('\t').append(hasOld ? oldCells[6] : "");   // correction
			sbResult.append('\t').append(casing);
			sbResult.append('\t').append(wasOldCategorized ? oldCells[8] : language);
			
			sbResult.append('\t').append(isFreqEnglish || (hasOld && oldCells[9] == "1") ? "1" : "");
			sbResult.append('\t').append(isFreqGerman || (hasOld && oldCells[10] == "1") ? "1" : "");
			sbResult.append('\t').append(ABAP.isAbapUpperCaseKeyword(word) || ABAP.isAbapLowerCaseKeyword(word) ? "1" : "");
			sbResult.append('\t').append(DDL.isDdlKeyword(word) || DDL.isDclKeyword(word) ? "1" : "");
			sbResult.append('\t').append(context);
			
			sbResult.append(System.lineSeparator());
		}

		// add remaining entries from the old table which were not covered above
		if (oldLineOfWord != null && oldLineOfWord.size() > 0) {
			for (String word : oldLineOfWord.keySet()) {
				sbResult.append(oldLineOfWord.get(word));
				sbResult.append(System.lineSeparator());
			}
		}
		
		return sbResult.toString();
	}

	public class CorrectionResult {
		public final String correctedText;
		public final ArrayList<String> corrections;

		public boolean wasAnythingCorrected() { return (correctedText != null); }
		
		public CorrectionResult(String correctedText, ArrayList<String> corrections) {
			this.correctedText = correctedText;
			this.corrections = corrections;
		}
	}

	public CorrectionResult correctComment(String text, boolean correctTypos, boolean changeBritishToAmerican) {
		return correctText(text, false, '\0', correctTypos, changeBritishToAmerican);
	}
	
	public CorrectionResult correctLiteral(String text, char escapeChar, boolean correctTypos, boolean changeBritishToAmerican) {
		return correctText(text, true, escapeChar, correctTypos, changeBritishToAmerican);
	}

	private CorrectionResult correctText(String text, boolean isLiteral, char escapeChar, boolean correctTypos, boolean changeBritishToAmerican) {
		if (!isInitialized) 
			initialize();

		TextReader reader = isLiteral ? TextReader.createForLiteral(text, escapeChar) : TextReader.createForComment(text);

		int correctionCount = 0;
		do {
			String word = reader.getNextWord();
			if (word == null)
				break;

			// if the word is a typo or British English, get the corresponding correction;
			// note that frequentEnglishTypos contains some entries which are sure to be typos,
			// but there is no unambiguous correction, so correction is "", and nothing can be corrected
			String correction = null;
			boolean isTypo = false;
			if (correctTypos) {
				correction = frequentEnglishTypos.get(word);
				isTypo = !StringUtil.isNullOrEmpty(correction);
			}
			if (changeBritishToAmerican && !isTypo) {
				correction = frequentBritishEnglish.get(word);
			}
			
			if (!StringUtil.isNullOrEmpty(correction)) {
				String diagnosis = isTypo ? "typo" : "BE";
				reader.correctLastWord(correction, diagnosis);
				++correctionCount;
			}
		} while(true);
		
		return (correctionCount == 0) ? null : new CorrectionResult(reader.getCorrectedText(), reader.getCorrections());
	}
}